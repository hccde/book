深入理解计算机系统
四个抽象
cpu 抽象成 进程
程序存储器 抽象成 虚拟内存
io设备抽象成 文件
计算机 抽象成 虚拟机

抽象是为了掩盖实现的差异

指针的字节数和寻址空间的能力一致 因为你的指针可以指向可寻址空间的任何一处地方 所以指针的字节数等于寻址空间 在32位机器上是4个字节 4*8 在64位机器上是8个字节

对于不同编译器 int 一般都是四位字长 long int的长度则不一定 取决于编译器 采用 LP4模型的 是64 如linux上 long long int 和 long int 一样长 都是64 而在 vs 上 则是 long int 为32  long long int 是64 采用的是 LLP模型

大端机  小端机  0x1234  34是低位 12是高位 
大端机表示为 12 34
小端机表示为 34 12
大小端在socket编程 强制类型转换比较敏感 但是一但操作系统确定了 这个就确定了 尽管现在允许编程为大端机 小端机

交换两个变量的值不一定需要第三个变量 利用布尔代数可以完成只要两个变量之间相互运算就可以
int *a int *b  
*b = * a ^  *b;
*a = *a ^ *b;
*b = *a ^ *b;
即完成交换 使用了 布尔代数（a^b)^a = b

 左移都是*2 空位用0弥补 都是逻辑左移 
右移分为逻辑右移  算术右移 对于有符号数 都是算术右移动 对于无符号数是逻辑右移 算术移动在空位处补最高有效位  逻辑右移就是 补0

当移位的位数大于类型的位数 比如32位移动大于32位时 对于c来说 是ub 对于java来说 则会计算 k mod w 来得到的 k是要移动的位数 w是类型的位数

有符号数的首位可以看成是一个 拥有权重为 -2^w的位



在强制转换的时候 数的位级并不会发送改变 改变的只是解释这个数的方式

对于无符号数和有符号数 相运算 c语言会将 有符号数转为无符号数再进行预算 并假设两个数都是非负的


why?
假设字长为一字节
负数在计算机中是用反码表示的 可 -0 也就是原码为 1000 0000的数是会产生进位的 忽略进位 为 0000 0000 这也是+0的补码表示 相对应的 补码为 1000 0000的码需要借位，进位可以忽略 但是借位就难办了 因此 补码为 1000 0000的码没有对应的原码 所以用作最小值 同样的道理：
1000000000000000的原码不存在 于是用作负的最大值

为什么要用补码来表示 因为 二进制加法 没有符号直接相加即可 可是有符号则不能直接相加 因为符号的原因 导致带符号加法 和无符号加法不同 导致要两种加法电路 这很浪费 因此 我们在上面一层用补码来表示可以简化电路设计
此外还有一个原因 就是用原码来表示的话 +0 和 -0 还要区分 一个是 1000 0000 一个是 0000 0000

类型相加 有正溢出和负溢出 正溢出小于任何一个加数 负溢出....

两个数相乘是mod了一个2^w的

乘法的时钟周期比较长 被变成移位和加法 即便发生溢出也只取低位的 结果也对 编译器会将乘法优化成移位

除法的时间也更久 除以2 我们可以表示为移位 但是不是任意的k 都可以表示为移位

浮点数阶码的存储是 val - 127 （8位阶码）也就是阶码最高位决定了 exp是正的还是负的

浮点数 规定尾数不能为以0 开头 所以尾数从0开始的称为非规格化数 因此有了最小非规格化数 最大非规格化数 最小规格化数 最大规格化数 再加上+0 -0 无穷大 NAN。非规格化数可以平滑过渡到规格化数 这归功于我们的阶码的表示是 val-127 不然的话规格化数就是从1开始的

向偶数舍入 比向上舍入或者向下舍入要更接近平均值
四舍五入对于0.5的情况的思考

浮点数运算不具有结合性的群属性

重用要基于它所依赖的假设

超线程 多核 的概念
机器层面 汇编语言 没有数据和指针的区别 也没有类型的区别

x86-64的指令长度从1到15字节不等 常用的指令以及操作数较少的指令所需要的字节较少

 